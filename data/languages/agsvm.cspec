<?xml version="1.0" encoding="UTF-8"?>

<!-- See Relax specification: Ghidra/Framework/SoftwareModeling/data/languages/compiler_spec.rxg -->

<!-- NOTES:
    - (TODO) It seems that calling conventions work as intended at this point
        the only exception is "nearcall" and "nearcallas", these two tend
        to mess up a stack from time to time, I guess that's expected
        since "extrapop" is "unknown" but it doesn't work even when there's
        no function arguments that it expects to be passed into it...
    
    - (SOLVED) PROBLEM:
        For now farcall and call stacks are the same and it seems to work fine
        for unoptimized assembly outputed by the classic AGS compiler, but
        if something is pushed onto the stack after farpush instruction
        (ether optimized or manually written code) the parameter order for
        a farcall will be incorrect!
        Is there a way to "split" a stack into two separate "sections"?
        I guess we could introduce another "stack pointer" register and use
        it for farpush, farcall and farsubsp instructions...
        The problem here is that Ghidra's analysis will be wrong in this case,
        right? Also, parameters order is reversed.
        
      SOLUTION:
        Ended up using two temporary memory spaces: "farStack" and "paramStack".
        "farStack" is used to store data pushed and poped with "farpush" and "farsubsp"
        instructions as is (implemented directly in Sleigh).
        "paramStack" is used to actually pass arguments into a farcall'd function by
        using a p-code injection for "farcall" instruction which copies N arguments
        from a top of "farStack" to "paramStack" and makes a call.
        The arguments count (N) is determined by "setfuncargs" instruction or by a
        number of pushed arguments onto "farStack" if there's no such instruction
        (like in very old SCOM3 versions)
 -->

<compiler_spec>
	<data_organization>
		<char_type signed="false" />
		<char_size value="1" />
		<short_size value="2" />
		<pointer_size value="4" />
		<integer_size value="4" />
		<float_size value="4" />
		<long_size value="4" />
		<double_size value="4" />
	</data_organization>

	<global>
		<range space="ram" />
	</global>

	<stackpointer register="sp" space="ram" growth="positive" />

	<default_proto>
		<!-- <prototype name="__agscall" type="stdcall" extrapop="unknown" stackshift="-4">
            <input>
                <pentry minsize="1" maxsize="500" align="4">
                    <addr space="stack" offset="0xFFFFFE08"/>
                </pentry>
            </input>
            <output killedbycall="true">
                <pentry minsize="1" maxsize="4">
                    <register name="ax"/>
                </pentry>
            </output>
            <returnaddress>
                <varnode space="stack" offset="-4" size="4"/>
            </returnaddress>
            <unaffected>
                <register name="sp"/>
            </unaffected>
            <killedbycall>
                <register name="op"/>
            </killedbycall>
            <likelytrash>
                <register name="bx"/>
                <register name="cx"/>
                <register name="dx"/>
            </likelytrash>
            <localrange>
                <range space="stack"/>
            </localrange>
        </prototype> -->

		<prototype name="nearcall" extrapop="unknown" stackshift="-4">
			<input>
				<!-- TODO: increase stack size to 250*4; offset=twos(maxsize+4) -->
				<pentry minsize="1" maxsize="1000" align="4">
					<addr space="stack" offset="0xFFFFFC14" />
				</pentry>
			</input>
			<output>
				<pentry minsize="1" maxsize="4">
					<register name="ax" />
				</pentry>
			</output>

			<pcode inject="uponentry" dynamic="true" />

			<unaffected>
				<register name="sp" />
				<register name="op" />

				<!-- NOTE(adm244): if specified for all prototypes makes sure that high-variables 
				won't be created for assosiated memory addresses;
				Not sure if it's _THE_ best solution, but it sure works and
				decompiler properly marks "farStack" as temporary storage
				(search "int4 ActionRestrictLocal::apply(Funcdata &data)" in "coreaction.cc" for more info) -->
				<register name="_farsp" />
			</unaffected>
		</prototype>
	</default_proto>

	<prototype name="nearcallas" extrapop="unknown" stackshift="-4" hasthis="true">
		<input thisbeforeretpointer="true">
			<pentry minsize="1" maxsize="4">
				<register name="op" />
			</pentry>
			<pentry minsize="1" maxsize="1000" align="4">
				<addr space="stack" offset="0xFFFFFC14" />
			</pentry>
		</input>
		<output>
			<pentry minsize="1" maxsize="4">
				<register name="ax" />
			</pentry>
		</output>

		<pcode inject="uponentry" dynamic="true" />

		<unaffected>
			<register name="sp" />
			<register name="_farsp" />
		</unaffected>
	</prototype>

	<!-- NOTE(adm244): these are used to generate pcode for functions "prologue" and "epilogue"(?)
        which is CALLMECHANISM_TYPE in InjectPayload interface -->
	<!-- <pcode inject="uponentry" dynamic="true"/> -->
	<!-- <pcode inject="uponreturn" dynamic="true"/> -->

	<prototype name="farcall" extrapop="0" stackshift="0">
		<input>
			<pentry minsize="1" maxsize="1000" align="4">
				<addr space="paramStack" offset="4" />
			</pentry>
		</input>
		<output>
			<pentry minsize="1" maxsize="4">
				<register name="ax" />
			</pentry>
		</output>
		<unaffected>
			<register name="sp" />
			<register name="op" />
			<register name="_farsp" />
		</unaffected>
	</prototype>

	<prototype name="farcallas" extrapop="0" stackshift="0" hasthis="true">
		<input thisbeforeretpointer="true">
			<pentry minsize="1" maxsize="4">
				<register name="op" />
			</pentry>
			<pentry minsize="1" maxsize="1000" align="4">
				<addr space="paramStack" offset="4" />
			</pentry>
		</input>
		<output>
			<pentry minsize="1" maxsize="4">
				<register name="ax" />
			</pentry>
		</output>
		<unaffected>
			<register name="sp" />
			<register name="_farsp" />
		</unaffected>
	</prototype>

	<callotherfixup targetop="memcpyCallOther">
		<pcode dynamic="true">
			<input name="value_immediate" />
			<input name="size_immediate" />
		</pcode>
	</callotherfixup>

	<callotherfixup targetop="movlitCallOther">
		<pcode dynamic="true">
			<input name="value_immediate" />
			<output name="value_output" />
		</pcode>
	</callotherfixup>

	<callotherfixup targetop="farcallCallOther">
		<pcode dynamic="true">
			<input name="address_register" />
		</pcode>
	</callotherfixup>

	<callotherfixup targetop="memzeroCallOther">
		<pcode dynamic="true">
			<input name="size_immediate" />
		</pcode>
	</callotherfixup>
</compiler_spec>
