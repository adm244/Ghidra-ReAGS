<?xml version="1.0" encoding="UTF-8"?>

<!-- See Relax specification: Ghidra/Framework/SoftwareModeling/data/languages/compiler_spec.rxg -->

<!-- NOTES:
    - (TODO) There's a "problem" with "boolean and" and "boolean or" instructions.
        For multiple and's and or's AGS compiler outputs a series of "if" statements
        which looks awful in the decompiled output. It can be detected by a series of
        "jz" instructions pointing to another "jz" instruction until it reaches the
        last basic block for this series. Maybe we can "help" the decompiler to
        optimize this mess?

    - (SOLVED???) It seems that calling conventions work as intended at this point
        the only exception is "nearcall" and "nearcallas", these two tend
        to mess up a stack from time to time, I guess that's expected
        since "extrapop" is "unknown" but it doesn't work even when there's
        no function arguments that it expects to be passed into it...
    
    - (SOLVED) PROBLEM:
        For now farcall and call stacks are the same and it seems to work fine
        for unoptimized assembly outputed by the classic AGS compiler, but
        if something is pushed onto the stack after farpush instruction
        (ether optimized or manually written code) the parameter order for
        a farcall will be incorrect!
        Is there a way to "split" a stack into two separate "sections"?
        I guess we could introduce another "stack pointer" register and use
        it for farpush, farcall and farsubsp instructions...
        The problem here is that Ghidra's analysis will be wrong in this case,
        right? Also, parameters order is reversed.
        
      SOLUTION:
        Ended up using two temporary memory spaces: "farStack" and "paramStack".
        "farStack" is used to store data pushed and poped with "farpush" and "farsubsp"
        instructions as is (implemented directly in Sleigh).
        "paramStack" is used to actually pass arguments into a farcall'd function by
        using a p-code injection for "farcall" instruction which copies N arguments
        from a top of "farStack" to "paramStack" and makes a call.
        The arguments count (N) is determined by "setfuncargs" instruction or by a
        number of pushed arguments onto "farStack" if there's no such instruction
        (like in very old SCOM3 versions)
 -->

<compiler_spec>
	<data_organization>
		<char_type signed="false" />
		<char_size value="1" />
		<short_size value="2" />
		<pointer_size value="4" />
		<integer_size value="4" />
		<float_size value="4" />
		<long_size value="4" />
		<double_size value="4" />
	</data_organization>

	<global>
		<range space="ram" />
	</global>

	<stackpointer register="sp" space="ram" growth="positive" />
	<deadcodedelay space="stack" delay="2" />

	<!-- FIXME(adm244): the "farStack" problem is STILL EXISTS!!! -->

	<!-- INVESTIGATE(adm244): "This routine is used by the initialization process to add
	address ranges to which there is never an (indirect) pointer" -->
	<!--<element name="nohighptr">
		<oneOrMore>
			<ref name="memory_tags_type" />
		</oneOrMore>
	</element>-->
	<!--<nohighptr>
		<register name="_farsp" />
		<range space="farSpace" first="0" last="0xFFFFFFFF" />
	</nohighptr>-->

	<!-- TODO(adm244): investigate if we can use this to create a "stack" for "farcall" -->
	<!-- "This process sets up a 'register relative' space for this architecture." -->
	<!-- NOTE(adm244): this "might" solve "farStack" problem... -->
	<spacebase name="farStack" register="_farsp" space="farSpace" />

	<default_proto>
		<prototype name="nearcall" extrapop="-4" stackshift="-4">
			<input>
				<!-- NOTE: offset=twos(maxsize+4) -->
				<pentry minsize="1" maxsize="1000" align="4">
					<addr space="stack" offset="0xFFFFFC14" />
				</pentry>
			</input>
			<output>
				<pentry minsize="1" maxsize="4">
					<register name="ax" />
				</pentry>
			</output>
			<likelytrash>
				<register name="ax" />
				<register name="bx" />
				<register name="cx" />
				<register name="dx" />
			</likelytrash>
			<unaffected>
				<register name="sp" />
				<register name="op" />

				<!-- NOTE(adm244): if specified for all prototypes makes sure that high-variables 
				won't be created for assosiated memory addresses;
				Not sure if it's _THE_ best solution, but it sure works and
				decompiler properly marks "farStack" as temporary storage
				(search "int4 ActionRestrictLocal::apply(Funcdata &data)" in "coreaction.cc" for more info) -->
				<register name="_farsp" />
			</unaffected>
			<!-- FIXME(adm244): turned off for now since it causes "farStack" issues -->
			<!--<localrange>
				<range space="stack" />
			</localrange>-->
			<!--<pcode inject="uponentry" dynamic="true" />-->
		</prototype>
	</default_proto>

	<!-- TODO(adm244): rename to "__thiscall" since it's forced to have one anyways -->
	<prototype name="nearcallas" extrapop="unknown" stackshift="-4" hasthis="true">
		<input>
			<pentry minsize="1" maxsize="4">
				<register name="op" />
			</pentry>
			<pentry minsize="1" maxsize="1000" align="4">
				<addr space="stack" offset="0xFFFFFC14" />
			</pentry>
		</input>
		<output>
			<pentry minsize="1" maxsize="4">
				<register name="ax" />
			</pentry>
		</output>
		<likelytrash>
			<register name="ax" />
			<register name="bx" />
			<register name="cx" />
			<register name="dx" />
		</likelytrash>
		<unaffected>
			<register name="sp" />
			<register name="_farsp" />
		</unaffected>
		<!--<localrange>
			<range space="stack" />
		</localrange>-->
		<!--<pcode inject="uponentry" dynamic="true" />-->
	</prototype>

	<!-- FIXME(adm244): remove this, since farcall will be used as a POINTER_METHOD from ConstantPool -->
	<prototype name="farcall" extrapop="0" stackshift="0">
		<input>
			<pentry minsize="1" maxsize="1000" align="4">
				<addr space="paramStack" offset="4" />
			</pentry>
		</input>
		<output>
			<pentry minsize="1" maxsize="4">
				<register name="ax" />
			</pentry>
		</output>
		<unaffected>
			<register name="sp" />
			<register name="op" />
			<register name="_farsp" />
		</unaffected>
	</prototype>

	<prototype name="farcallas" extrapop="0" stackshift="0" hasthis="true">
		<input>
			<pentry minsize="1" maxsize="4">
				<register name="op" />
			</pentry>
			<pentry minsize="1" maxsize="1000" align="4">
				<addr space="paramStack" offset="4" />
			</pentry>
		</input>
		<output>
			<pentry minsize="1" maxsize="4">
				<register name="ax" />
			</pentry>
		</output>
		<unaffected>
			<register name="sp" />
			<register name="_farsp" />
		</unaffected>
	</prototype>

	<callotherfixup targetop="memcpyCallOther">
		<pcode dynamic="true">
			<input name="value_immediate" />
			<input name="size_immediate" />
		</pcode>
	</callotherfixup>

	<callotherfixup targetop="movlitCallOther">
		<pcode dynamic="true">
			<input name="value_immediate" />
			<output name="value_output" />
		</pcode>
	</callotherfixup>

	<callotherfixup targetop="farcallCallOther">
		<pcode dynamic="true">
			<input name="address_register" />
		</pcode>
	</callotherfixup>

	<callotherfixup targetop="memzeroCallOther">
		<pcode dynamic="true">
			<input name="size_immediate" />
		</pcode>
	</callotherfixup>

	<!--<callotherfixup targetop="arrnewCallOther">
		<pcode dynamic="true">
			<input name="size_immediate" />
			<input name="type_immediate" />
		</pcode>
	</callotherfixup>-->
</compiler_spec>
