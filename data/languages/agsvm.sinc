# sleigh specification file for AGSVM

define endian=little;

define alignment=4;

define space ram type=ram_space size=4 default;
define space register type=register_space size=4;
define space farStack type=ram_space size=4;
define space paramStack type=ram_space size=4;

# general purpose registers
define register offset=0x00 size=4 [ ax bx cx dx ];
# special meaning registers
define register offset=0x14 size=4 [ sp op mar ];
# utility registers not present in virtual machine
define register offset=0x20 size=4 [ pc counter _farsp ]; # _farsp _paramsp _funcArgs

# operations used for p-code injection
define pcodeop farcallCallOther;
#define pcodeop farpushCallOther;
#define pcodeop farsubspCallOther;
define pcodeop setfuncargsCallOther;
define pcodeop movlitCallOther;

# operations used as black-box functions
define pcodeop strcmp;

#TOKENS
define token operation (32)
    opcode   = ( 0,23)
    instance = (24,31)
;

define token operand (32)
    reg1 = (0, 2)
    reg2 = (0, 2)
    arg1 = (0,31) signed
    arg2 = (0,31) signed
    arg3 = (0,31) signed
;

attach variables [ reg1 reg2 ] [ _ sp mar ax bx cx op dx ];

# MARCO
macro push(x) {
    *:4 sp = x;
    sp = sp + 4;
}

macro pop(x) {
    sp = sp - 4;
    x = *:4 sp;
}

macro farpush(x) {
    *[farStack]:4 _farsp = x;
    _farsp = _farsp - 4;
#    push(x);
}

#macro farpeek(x, i) {
#    _pos:4 = _farsp + ((i + 1) * 4);
#    x = *[farStack]:4 _pos;
#}

macro farsubsp(x) {
    _farsp = _farsp + (x * 4);
#    sp = sp - (x * 4);
}

#
#macro parampush(x) {
#    *[paramStack]:4 _paramsp = x;
#    _paramsp = _paramsp - 4;
#}
#
#macro paramreset() {
#    _paramsp = 1000;
#}
# Constructors
dest: rel  is arg1 [ rel = inst_next + (arg1 * 4); ] {
    export *:4 rel;
}

# Instructions
# add (imm)
:add reg1, arg2        is opcode=0x01; reg1; arg2 {
    reg1 = reg1 + arg2;
}

# sub (imm)
:sub reg1, arg2        is opcode=0x02; reg1; arg2 {
    reg1 = reg1 - arg2;
}

# regtoreg
:mov reg2, reg1        is opcode=0x03; reg1; reg2 {
    reg2 = reg1;
}

# writelit
:memcpy arg2, arg1     is opcode=0x04; arg1; arg2 {
    if (arg1:4 == 1) goto <byte>;
    if (arg1:4 == 2) goto <word>;

    *:4 mar = arg2:4;
    goto inst_next;

    <byte>
    *:1 mar = arg2:1;
    goto inst_next;

    <word>
    *:2 mar = arg2:2;
}

# ret
:ret                   is opcode=0x05 {
    pop(pc);
    return [pc];
}

# littoreg
:mov reg1, arg2        is opcode=0x06; reg1; arg2 {
#    reg1 = arg2;
    reg1 = movlitCallOther(arg2:4);
}

# memread
:memread4 reg1         is opcode=0x07; reg1 {
    reg1 = *:4 mar;
}

# memwrite
:memwrite4 reg1        is opcode=0x08; reg1 {
    *:4 mar = reg1;
}

# mulreg
:mul reg1, reg2        is opcode=0x09; reg1; reg2 {
    reg1 = reg1 * reg2;
}

# divreg
:div reg1, reg2        is opcode=0x0a; reg1; reg2 {
    reg1 = reg1 / reg2;
}

# addreg
:add reg1, reg2        is opcode=0x0b; reg1; reg2 {
    reg1 = reg1 + reg2;
}

# subreg
:sub reg1, reg2        is opcode=0x0c; reg1; reg2 {
    reg1 = reg1 - reg2;
}

# bitand
:and reg1, reg2        is opcode=0xd; reg1; reg2 {
    reg1 = reg1 & reg2;
}

# bitor
:or reg1, reg2         is opcode=0xe; reg1; reg2 {
    reg1 = reg1 | reg2;
}

# isequal
:cmpeq reg1, reg2      is opcode=0x0f; reg1; reg2 {
    reg1 = zext(reg1 == reg2);
}

# notequal
:cmpneq reg1, reg2     is opcode=0x10; reg1; reg2 {
    reg1 = zext(reg1 != reg2);
}

# greater
:cmpgt reg1, reg2      is opcode=0x11; reg1; reg2 {
    reg1 = zext(reg1 s> reg2);
}

# lessthan
:cmplt reg1, reg2      is opcode=0x12; reg1; reg2 {
    reg1 = zext(reg1 s< reg2);
}

# gte
:cmpge reg1, reg2      is opcode=0x13; reg1; reg2 {
    reg1 = zext(reg1 s>= reg2);
}

# lte
:cmple reg1, reg2      is opcode=0x14; reg1; reg2 {
    reg1 = zext(reg1 s<= reg2);
}

# and (logical)
:land reg1, reg2       is opcode=0x15; reg1; reg2 {
    if (reg1 == 0) goto <false>;
    if (reg2 == 0) goto <false>;

    reg1 = 1;
    goto inst_next;

    <false>
    reg1 = 0;
}

# or (logical)
:lor reg1, reg2        is opcode=0x16; reg1; reg2 {
    if (reg1 != 0) goto <true>;
    if (reg2 != 0) goto <true>;

    reg1 = 0;
    goto inst_next;

    <true>
    reg1 = 1;
}

# call
:call reg1             is opcode=0x17; reg1 {
    push(&:4 inst_next);
    call [reg1];
}

# memreadb
:memread1 reg1         is opcode=0x18; reg1 {
    reg1 = *:1 mar;
}

# memreadw
:memread2 reg1         is opcode=0x19; reg1 {
    reg1 = *:2 mar;
}

# memwriteb
:memwrite1 reg1        is opcode=0x1a; reg1 {
    *:1 mar = reg1;
}

# memwritew
:memwrite2 reg1        is opcode=0x1b; reg1 {
    *:2 mar = reg1;
}

# jz
:jz dest               is opcode=0x1c; dest {
    if (ax == 0) goto dest;
}

# pushreg
:push reg1             is opcode=0x1d; reg1 {
    push(reg1);
}

# popreg
:pop reg1              is opcode=0x1e; reg1 {
    pop(reg1);
}

# jmp
:jmp dest              is opcode=0x1f; dest {
    goto dest;
}

# mul (imm)
:mul reg1, arg2        is opcode=0x20; reg1; arg2 {
    reg1 = reg1 * arg2;
}

# callext
:farcall reg1          is opcode=0x21; reg1 {
#    NOTE(adm244): this must be a default push since we don't account for return address
#    push(&:4 inst_next);
#    farpush(&:4 inst_next);
#    reg1 = cpool(0:4, 5:4, reg1);
#    farcallCallOther(_funcArgs, reg1);
#    call [reg1];
# THIS IS A MOCK P-CODE THAT REPRESENTS WHAT INSTRUCTION SHOULD DO. DO _NOT_ USE!
#    local _addr:4 = reg1;
#    local _iter:4 = 0;
#    local _count:4;
#
#    if (_funcArgs >= 0) goto <pre_cycle>;
#
#    _count = (1000 - _farsp) / 4;
#    goto <start>;
#
#    <pre_cycle>
#    _count = _funcArgs;
#
#    <start>
#    if (_iter == _count) goto <end>;
#
#    farpeek(ax, _iter);
#    parampush(ax);
#    _iter = _iter + 1;
#    goto <start>;
#
#    <end>
#    call [_addr];
#
#    paramreset();
#    _funcArgs = -1;
    farcallCallOther(reg1);
#    call [reg1];
}

# pushreal
:farpush reg1          is opcode=0x22; reg1 {
#    push(reg1);
    farpush(reg1);
#    value:4 = reg1;
#    farpushCallOther(reg1);
}

# subrealstack
:farsubsp arg1         is opcode=0x23; arg1 {
#    sp = sp - (arg1 * 4);
#    farsubsp(arg1);
#    NOTE(adm244): passing 'ax' here so in payload we can ignore symbolic propagator pass
#    farsubspCallOther(ax, arg1:4);
}

# linenum
:sourceline arg1       is opcode=0x24; arg1 {
    # NOP
}

# callas
:callscr arg1          is opcode=0x25; arg1 {
}

# thisbase
:thisaddr              is opcode=0x26; arg1 {
#    FIXME(adm244): incorrect address 
#    bp = arg1;
#    _farsp = 1000;
#    _paramsp = 1000;
}

# numfuncargs
:setfuncargs arg1      is opcode=0x27; arg1 {
#    setfuncargsCallOther(arg1:4);
#    _funcArgs = arg1;
}

# modreg
:mod reg1, reg2        is opcode=0x28; reg1; reg2 {
    reg1 = reg1 % reg2;
}

# xorreg
:xor reg1, reg2        is opcode=0x29; reg1; reg2 {
    reg1 = reg1 ^ reg2;
}

# notreg
:lnot reg1             is opcode=0x2a; reg1 {
    if (reg1 == 0) goto <false>;

    reg1 = 0;
    goto inst_next;

    <false>
    reg1 = 1;
}

# shiftleft
:shl reg1, reg2        is opcode=0x2b; reg1; reg2 {
    reg1 = reg1 << reg2;
}

# shiftright
:shr reg1, reg2        is opcode=0x2c; reg1; reg2 {
    reg1 = reg1 >> reg2;
}

# callobj
:mov op, reg1          is opcode=0x2d & op; reg1 {
    op = reg1;
}

# checkbounds
:assertlte reg1, arg2  is opcode=0x2e; reg1; arg2 {
#    assert(reg1:4, 0:4, arg2:4);
    # NOP
}

# memwriteptr
:memwrite.ptr reg1     is opcode=0x2f; reg1 {
    *:4 mar = reg1;
}

# memreadptr
:memread.ptr reg1      is opcode=0x30; reg1 {
    reg1 = *:4 mar;
}

# memzeroptr
:memzero.ptr           is opcode=0x31 {
    *:4 mar = 0;
}

# meminit
:meminit reg1          is opcode=0x32; reg1 {
    *:4 mar = reg1;
}

#define pcodeop log;

# loadspoffs
:stackptr arg1         is opcode=0x33; arg1 {
    mar = sp - arg1;
#    log(sp, arg1:4, mar);
}

# checknull
:assert mar            is opcode=0x34 & mar {
#    assert(mar);
    # NOP
}

# fadd
:fadd reg1, arg2       is opcode=0x35; reg1; arg2 {
    reg1 = reg1 f+ arg2;
}

# fsub
:fsub reg1, arg2       is opcode=0x36; reg1; arg2 {
    reg1 = reg1 f- arg2;
}

# fmulreg
:fmul reg1, reg2       is opcode=0x37; reg1; reg2 {
    reg1 = reg1 f* reg2;
}

# fdivreg
:fdiv reg1, reg2       is opcode=0x38; reg1; reg2 {
    reg1 = reg1 f/ reg2;
}

# faddreg
:fadd reg1, reg2       is opcode=0x39; reg1; reg2 {
    reg1 = reg1 f+ reg2;
}

# fsubreg
:fsub reg1, reg2       is opcode=0x3a; reg1; reg2 {
    reg1 = reg1 f- reg2;
}

# fgreater
:fcmpgt reg1, reg2     is opcode=0x3b; reg1; reg2 {
    reg1 = zext(reg1 f> reg2);
}

# flessthan
:fcmplt reg1, reg2     is opcode=0x3c; reg1; reg2 {
    reg1 = zext(reg1 f< reg2);
}

# fgte
:fcmpge reg1, reg2     is opcode=0x3d; reg1; reg2 {
    reg1 = zext(reg1 f>= reg2);
}

# flte
:fcmple reg1, reg2     is opcode=0x3e; reg1; reg2 {
    reg1 = zext(reg1 f<= reg2);
}

# zeromemory
:memzero arg1          is opcode=0x3f; arg1 {
    counter = 0;

    <start>
    if (counter == arg1) goto inst_next;

    *:4 mar + counter = 0;
    counter = counter + 1;

    goto <start>;
}

# createstring
:strnew reg1           is opcode=0x40; reg1 {
#    TODO(adm244): reg1 is offset into .strings
#    reg1 = newobject(reg1);
#    reg1 = *[strings]:4 reg1;
    reg1 = reg1;
}

# stringsequal
:streq reg1, reg2      is opcode=0x41; reg1; reg2 {
    local tmp:4 = strcmp(reg1, reg2);

    if (tmp == 0) goto <true>;

    reg1 = 0;
    goto inst_next;

    <true>
    reg1 = 1;
}

# stringsnoteq
:strneq reg1, reg2     is opcode=0x42; reg1; reg2 {
    local tmp:4 = strcmp(reg1, reg2);

    if (tmp != 0) goto <true>;

    reg1 = 0;
    goto inst_next;

    <true>
    reg1 = 1;
}

# checknullreg
:assert reg1           is opcode=0x43; reg1 {
#    assert(reg1);
    # NOP
}

# loopcheckoff
:loopcheckoff          is opcode=0x44 {
    # NOP
}

# memzeroptrnd
:memzerond             is opcode=0x45 {
    *:4 mar = 0;
}

# jnz
:jnz dest              is opcode=0x46; dest {
    if (ax != 0) goto dest;
}

# dynamicbounds
:dynamicbounds reg1    is opcode=0x47; reg1 {
    # NOP
}

# newarray
:arrnew reg1, arg2, arg3  is opcode=0x48; reg1; arg2; arg3 {
    reg1 = newobject(reg1, arg2:4, arg3:4);
}

# newuserobject
:objnew reg1, arg2     is opcode=0x49; reg1; arg2 {
    reg1 = newobject(reg1, arg2:4);
}

## sleigh include file for Skeleton language instructions
#
#define token opbyte (8)
#   op0_8     = (0,7)
#   op6_2     = (6,7)
#   
#   dRegPair4_2    = (4,5)
#   pRegPair4_2    = (4,5)
#   sRegPair4_2    = (4,5)
#   qRegPair4_2    = (4,5)
#   qRegPair4_2a   = (4,5)
#   qRegPair4_2b   = (4,5)
#   rRegPair4_2    = (4,5)
#
#   reg3_3 = (3,5)
#   bits3_3   = (3,5)
#   
#   bits0_4   = (0,3)
#   
#   reg0_3 = (0,2)
#   bits0_3   = (0,2)
#;
#
#define token data8 (8)
#   imm8		= (0,7)
#   sign8	= (7,7)
#   simm8	= (0,7) signed
#;
#
#define token data16 (16)
#   timm4        = (12,15)
#   imm16        = (0,15)
#   sign16		= (15,15)
#   simm16		= (0,15) signed
#;
#
#attach variables [ reg0_3 reg3_3 ] [ B C D E H L _ A ];
#
#attach variables [ sRegPair4_2 dRegPair4_2 ] [ BC DE HL SP ];
#
#attach variables [ qRegPair4_2 ] [ BC DE HL AF ];
#attach variables [ qRegPair4_2a ] [ B D H A ];
#attach variables [ qRegPair4_2b ] [ C E L F ];
#
#attach variables [ pRegPair4_2 ] [ BC DE IX SP ];
#attach variables [ rRegPair4_2 ] [ BC DE IY SP ];
#
#################################################################
## Macros
#################################################################
#
#macro setResultFlags(result) {
#	$(Z_flag) = (result == 0);
#	$(S_flag) = (result s< 0);
#}
#
#macro setAddCarryFlags(op1,op2) {
#	$(C_flag) = (carry(op1,zext($(C_flag))) || carry(op2,op1 + zext($(C_flag))));
#}
#
#macro setAddFlags(op1,op2) {
#	$(C_flag) = carry(op1,op2);
#}
#
#macro setSubtractCarryFlags(op1,op2) {
#	notC = ~$(C_flag);
#	$(C_flag) = ((op1 < sext(notC)) || (op2 < (op1 - sext(notC))));
#}
#
#macro setSubtractFlags(op1,op2) {
#	$(C_flag) = (op1 < op2);
#}
#
#macro push16(val16) {
#	SP = SP - 2;
#	*:2 SP = val16; 
#}
#
#macro pop16(ret16) {
#	ret16 = *:2 SP;
#	SP = SP + 2; 
#}
#
#macro push8(val8) {
#	SP = SP - 1;
#	ptr:2 = SP;
#	*:1 ptr = val8; 
#}
#
#macro pop8(ret8) {
#    ptr:2 = SP;
#	ret8 = *:1 ptr;
#	SP = SP + 1; 
#}
#
#################################################################
#
#ixMem8: (IX+simm8)  is IX & simm8								{ ptr:2 = IX + simm8; export *:1 ptr; }
#ixMem8: (IX-val)    is IX & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IX + simm8; export *:1 ptr; }
#
#iyMem8: (IY+simm8)  is IY & simm8								{ ptr:2 = IY + simm8; export *:1 ptr; }
#iyMem8: (IY-val)    is IY & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IY + simm8; export *:1 ptr; }
#
#Addr16: imm16		is imm16									{ export *:1 imm16; }
#
#Mem16: (imm16)		is imm16									{ export *:2 imm16; }
#
#RelAddr8: loc		is simm8  [ loc = inst_next + simm8; ]		{ export *:1 loc; }
#
#cc: "NZ"            is bits3_3=0x0                              { c:1 = ($(Z_flag) == 0); export c; }
#cc: "Z"             is bits3_3=0x1                              { c:1 = $(Z_flag); export c; }
#cc: "NC"            is bits3_3=0x2                              { c:1 = ($(C_flag) == 0); export c; }
#cc: "C"             is bits3_3=0x3                              { c:1 = $(C_flag); export c; }
#cc: "PO"            is bits3_3=0x4                              { c:1 = ($(PV_flag) == 0); export c; }
#cc: "PE"            is bits3_3=0x5                              { c:1 = $(PV_flag); export c; }
#cc: "P"             is bits3_3=0x6                              { c:1 = ($(S_flag) == 0); export c; }
#cc: "M"             is bits3_3=0x7                              { c:1 = $(S_flag); export c; }
#
#cc2: "NZ"            is bits3_3=0x4                              { c:1 = ($(Z_flag) == 0); export c; }
#cc2: "Z"             is bits3_3=0x5                              { c:1 = $(Z_flag); export c; }
#cc2: "NC"            is bits3_3=0x6                              { c:1 = ($(C_flag) == 0); export c; }
#cc2: "C"             is bits3_3=0x7                              { c:1 = $(C_flag); export c; }
#
#################################################################
#
#
#:LD IX,Mem16  is op0_8=0xdd & IX; op0_8=0x2a; Mem16 {
#	IX = Mem16;
#}
#
#:LD IY,Mem16  is op0_8=0xfd & IY; op0_8=0x2a; Mem16 {
#	IY = Mem16;
#}
#
#:LD Mem16,HL  is op0_8=0x22 & HL; Mem16 {
#	Mem16 = HL;
#}
#
#:LD Mem16,dRegPair4_2  is op0_8=0xed; op6_2=0x1 & dRegPair4_2 & bits0_4=0x3; Mem16 {
#	Mem16 = dRegPair4_2;
#}
#
#:LD Mem16,IX  is op0_8=0xdd & IX; op0_8=0x22; Mem16 {
#	Mem16 = IX;
#}
#
#:LD Mem16,IY  is op0_8=0xfd & IY; op0_8=0x22; Mem16 {
#	Mem16 = IY;
#}
#
#:NEG  is op0_8=0xed; op0_8=0x44 {
#	$(PV_flag) = (A == 0x80);
#	$(C_flag) = (A != 0);
#	A = -A;
#	setResultFlags(A);
#}
#
#:SET bits3_3,ixMem8  is op0_8=0xdd; op0_8=0xcb; ixMem8; op6_2=0x3 & bits3_3 & bits0_3=0x6 {
#	mask:1 = (1 << bits3_3);
#	val:1 = ixMem8;
#	ixMem8 = val | mask;
#}
#
#:SET bits3_3,iyMem8  is op0_8=0xfd; op0_8=0xcb; iyMem8; op6_2=0x3 & bits3_3 & bits0_3=0x6 {
#	mask:1 = (1 << bits3_3);
#	val:1 = iyMem8;
#	iyMem8 = val | mask;
#}
#
#:JP Addr16  is op0_8=0xc3; Addr16 {
#	goto Addr16;	
#}
#
#:JP cc,Addr16  is op6_2=0x3 & cc & bits0_3=0x2; Addr16 {
#	if (!cc) goto Addr16;
#}
#
#:JR RelAddr8  is op0_8=0x18; RelAddr8 {
#	goto RelAddr8;
#}
#
#:JR cc2,RelAddr8  is op6_2=0x0 & cc2 & bits0_3=0x0; RelAddr8 {
#	if (cc2) goto RelAddr8;
#}
#
#:JP (HL)  is op0_8=0xe9 & HL {
#	goto [HL];
#}
#
#:JP (IX)  is op0_8=0xdd & IX; op0_8=0xe9 {
#	goto [IX];
#}
#
#:JP (IY)  is op0_8=0xfd & IY; op0_8=0xe9 {
#	goto [IY];
#}
#
#:CALL Addr16  is op0_8=0xcd; Addr16 {
#    push16(&:2 inst_next);
#	call Addr16;
#}
#
#:CALL cc,Addr16  is op6_2=0x3 & cc & bits0_3=0x4; Addr16 {
#	if (!cc) goto inst_next;
#    push16(&:2 inst_next);
#	call Addr16;
#}
#
#:RET  is op0_8=0xc9 {
#	pop16(PC);
#	ptr:2 = zext(PC);
#	return [ptr];
#}
#
#:RET cc  is op6_2=0x3 & cc & bits0_3=0x0 {
#	if (!cc) goto inst_next;
#	pop16(PC);
#	ptr:2 = zext(PC);
#	return [ptr];
#}	
