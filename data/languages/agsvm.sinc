# sleigh specification file for AGSVM

define endian=little;
define alignment=4;

define space ram type=ram_space size=4 default;
# define space code type=ram_space size=4;
define space stackvirt type=ram_space size=4;
# define space stackreal type=ram_space size=4;

define space register type=register_space size=4;

# general purpose registers
define register offset=0x00 size=4 [ ax bx cx dx ];
# special registers
define register offset=0x20 size=4 [ sp op mar pc ];
# util registers
# define register offset=0x100 size=4 [ sp_real ];

# define pcodeop callext;

#TOKENS

define token operation (32)
  opcode = (0,23)
;

define token operand (32)
  reg1 = (0,2)
  reg2 = (0,2)
  arg1 = (0,31)
  arg2 = (0,31)
  arg3 = (0,31)
;

attach variables [ reg1 reg2 ] [ _ sp mar ax bx cx op dx ];

# MARCO

# macro push(x)
# {
#   addr = sp * 4;
#   *[stack]:4 addr = x:4;
#   sp = sp + 1;
# }

# macro pop(x)
# {
#   sp = sp - 1;
#   addr = sp * 4;
#   x:4 = *[stack]:4 addr;
# }

# macro pushreal(x)
# {
#   *[stackreal]:4 sp_real = x:4;
#   sp_real = sp_real + 1;
# }

# macro subreal(x)
# {
#   sp_real = sp_real - x;
# }

# Instructions

# add (imm)
:add reg1, arg2 is opcode=0x01; reg1; arg2
{
  # reg1 = reg1 + arg2;
}

# sub (imm)
:sub reg1, arg2 is opcode=0x02; reg1; arg2
{
  # reg1 = reg1 - arg2;
}

# regtoreg
:mov reg2, reg1 is opcode=0x03; reg1; reg2
{
  # reg2 = reg1;
}

# writelit
:copy [arg2], arg1 is opcode=0x04; arg1; arg2
{
  # *[ram]:8 MAR = *[ram]:8 arg2;
}

# :copy [mar], [arg2], arg1 is (opcode=0x04 & arg1=2); arg1; arg2
# {
#   # *[ram]:16 MAR = *[ram]:16 arg2;
# }

# :copy [mar], [arg2], arg1 is (opcode=0x04 & arg1=4); arg1; arg2
# {
#   # *[ram]:32 MAR = *[ram]:32 arg2;
# }

# ret
:ret is opcode=0x05
{
  # local addr = *[stack]:4 SP;
  # if (addr == 0) addr = AX;
  # return addr;
}

# littoreg
:mov reg1, arg2 is opcode=0x06; reg1; arg2
{
  # reg1 = arg2;
}

# memread
:mov reg1, "dword [mar]" is opcode=0x07; reg1
{
  # reg1 = *[ram]:4 mar;
}

# memwrite
:mov "dword [mar]", reg1 is opcode=0x08; reg1
{
  # *[ram]:4 mar = reg1;
}

# mulreg
:mul reg1, reg2 is opcode=0x09; reg1; reg2
{
  # reg1 = reg1 * reg2;
}

# divreg
:div reg1, reg2 is opcode=0x0a; reg1; reg2
{
  # reg1 = reg1 / reg2;
}

# addreg
:add reg1, reg2 is opcode=0x0b; reg1; reg2
{
  # reg1 = reg1 + reg2;
}

# subreg
:sub reg1, reg2 is opcode=0x0c; reg1; reg2
{
  # reg1 = reg1 - reg2;
}

# bitand
:and reg1, reg2 is opcode=0xd; reg1; reg2
{
  # reg1 = reg1 & reg2;
}

# bitor
:or reg1, reg2 is opcode=0xe; reg1; reg2
{
  # reg1 = reg1 | reg2;
}

# isequal
:cmpeq reg1, reg2 is opcode=0x0f; reg1; reg2
{
  # reg1 = reg1 == reg2;
}

# notequal
:cmpneq reg1, reg2 is opcode=0x10; reg1; reg2
{
  # reg1 = reg1 != reg2;
}

# greater
:cmpgt reg1, reg2 is opcode=0x11; reg1; reg2
{
  # reg1 = reg1 > reg2;
}

# lessthan
:cmplt reg1, reg2 is opcode=0x12; reg1; reg2
{
  # reg1 = reg1 < reg2;
}

# gte
:cmpge reg1, reg2 is opcode=0x13; reg1; reg2
{
  # reg1 = reg1 >= reg2;
}

# lte
:cmple reg1, reg2 is opcode=0x14; reg1; reg2
{
  # reg1 = reg1 <= reg2;
}

# and (logical)
:and reg1, reg2 is opcode=0x15; reg1; reg2
{
  # reg1 = reg1 && reg2;
}

# or (logical)
:or reg1, reg2 is opcode=0x16; reg1; reg2
{
  # reg1 = reg1 || reg2;
}

# call
:call reg1 is opcode=0x17; reg1
{
  # push(inst_next);
  # # FIXME: reg1 can be absolute or relative
  # addr = *[code]:4 reg1;
  # call addr;
}

# memreadb
:mov reg1, "byte [mar]" is opcode=0x18; reg1
{
  # reg1 = *[ram]:1 mar;
}

# memreadw
:mov reg1, "word [mar]" is opcode=0x19; reg1
{
  # reg1 = *[ram]:2 mar;
}

# memwriteb
:mov "byte [mar]", reg1 is opcode=0x1a; reg1
{
  # *[ram]:1 mar = reg1;
}

# memwritew
:mov "word [mar]", reg1 is opcode=0x1b; reg1
{
  # *[ram]:2 mar = reg1;
}

# jz
:jz arg1 is opcode=0x1c; arg1
{
  # if (ax == 0) goto [rel:4];
}

# pushreg
:push reg1 is opcode=0x1d; reg1
{
  # push(reg1);
}

# popreg
:pop reg1 is opcode=0x1e; reg1
{
  # pop(reg1);
}

# jmp
:jmp arg1 is opcode=0x1f; arg1
{
  # goto [rel:4];
}

# mul (imm)
:mul reg1, arg2 is opcode=0x20; reg1; arg2
{
  # reg1 = reg1 * arg2;
}

# callext
:call "far" reg1 is opcode=0x21; reg1
{
  # callext(reg1);
}

# pushreal
:push "far" reg1 is opcode=0x22; reg1
{
  # pushreal(reg1);
}

# subrealstack
:sub "sp", arg1 is opcode=0x23; arg1
{
  # subreal(arg1);
}

# linenum
:line arg1 is opcode=0x24; arg1
{
  # NOP
}

# callas
:callobj arg1 is opcode=0x25; arg1
{

}

# thisbase
:thisbase arg1 is opcode=0x26; arg1
{

}

# numfuncargs
:args arg1 is opcode=0x27; arg1
{

}

# modreg
:mod reg1, reg2 is opcode=0x28; reg1; reg2
{
  # reg1 = reg1 % reg2;
}

# xorreg
:xor reg1, reg2 is opcode=0x29; reg1; reg2
{
  # reg1 = reg1 ^ reg2;
}

# notreg
:lnot reg1 is opcode=0x2a; reg1
{
  # reg1 = !reg1;
}

# shiftleft
:shl reg1, reg2 is opcode=0x2b; reg1; reg2
{
  # reg1 = reg1 << reg2;
}

# shiftright
:shr reg1, reg2 is opcode=0x2c; reg1; reg2
{
  # reg1 = reg1 >> reg2;
}

# callobj
:mov "op", reg1 is opcode=0x2d; reg1
{
  # op = reg1;
}

# checkbounds
:assert reg1, arg2 is opcode=0x2e; reg1; arg2
{

}

# memwriteptr
:memmov "mar", reg1 is opcode=0x2f; reg1
{

}

# memreadptr
:memmov reg1, "mar" is opcode=0x30; reg1
{

}

# memzeroptr
:memzero "mar", 0 is opcode=0x31
{
  # mar = 0;
}

# meminit
:meminit "mar", reg1 is opcode=0x32; reg1
{

}

# loadspoffs
:stack arg1 is opcode=0x33; arg1
{

}

# checknull
:assert "mar" is opcode=0x34
{

}

# fadd
:fadd reg1, arg2 is opcode=0x35; reg1; arg2
{

}

# fsub
:fsub reg1, arg2 is opcode=0x36; reg1; arg2
{

}

# fmulreg
:fmul reg1, reg2 is opcode=0x37; reg1; reg2
{

}

# fdivreg
:fdiv reg1, reg2 is opcode=0x38; reg1; reg2
{

}

# faddreg
:fadd reg1, reg2 is opcode=0x39; reg1; reg2
{

}

# fsubreg
:fsub reg1, reg2 is opcode=0x3a; reg1; reg2
{

}

# fgreater
:fcmpgt reg1, reg2 is opcode=0x3b; reg1; reg2
{

}

# flessthan
:fcmplt reg1, reg2 is opcode=0x3c; reg1; reg2
{
  
}

# fgte
:fcmpge reg1, reg2 is opcode=0x3d; reg1; reg2
{

}

# flte
:fcmple reg1, reg2 is opcode=0x3e; reg1; reg2
{
  
}

# zeromemory
:memclear "mar", arg1 is opcode=0x3f; arg1
{

}

# createstring
:strnew reg1 is opcode=0x40; reg1
{

}

# stringsequal
:streq reg1, reg2 is opcode=0x41; reg1; reg2
{

}

# stringsnoteq
:strneq reg1, reg2 is opcode=0x42; reg1; reg2
{

}

# checknullreg
:assert reg1 is opcode=0x43; reg1
{

}

# loopcheckoff
:loopcheckoff is opcode=0x44
{
  # NOP
}

# memzeroptrnd
:memzerond "mar", 0 is opcode=0x45
{

}

# jnz
:jnz arg1 is opcode=0x46; arg1
{
  # if (ax != 0) goto [rel:4];
}

# dynamicbounds
:assert reg1, "mar" is opcode=0x47; reg1
{

}

# newarray
:arrnew reg1, arg2, arg3 is opcode=0x48; reg1; arg2; arg3
{

}

# newuserobject
:objnew reg1, arg2 is opcode=0x49; reg1; arg2
{

}

## sleigh include file for Skeleton language instructions
#
#define token opbyte (8)
#   op0_8     = (0,7)
#   op6_2     = (6,7)
#   
#   dRegPair4_2    = (4,5)
#   pRegPair4_2    = (4,5)
#   sRegPair4_2    = (4,5)
#   qRegPair4_2    = (4,5)
#   qRegPair4_2a   = (4,5)
#   qRegPair4_2b   = (4,5)
#   rRegPair4_2    = (4,5)
#
#   reg3_3 = (3,5)
#   bits3_3   = (3,5)
#   
#   bits0_4   = (0,3)
#   
#   reg0_3 = (0,2)
#   bits0_3   = (0,2)
#;
#
#define token data8 (8)
#   imm8		= (0,7)
#   sign8	= (7,7)
#   simm8	= (0,7) signed
#;
#
#define token data16 (16)
#   timm4        = (12,15)
#   imm16        = (0,15)
#   sign16		= (15,15)
#   simm16		= (0,15) signed
#;
#
#attach variables [ reg0_3 reg3_3 ] [ B C D E H L _ A ];
#
#attach variables [ sRegPair4_2 dRegPair4_2 ] [ BC DE HL SP ];
#
#attach variables [ qRegPair4_2 ] [ BC DE HL AF ];
#attach variables [ qRegPair4_2a ] [ B D H A ];
#attach variables [ qRegPair4_2b ] [ C E L F ];
#
#attach variables [ pRegPair4_2 ] [ BC DE IX SP ];
#attach variables [ rRegPair4_2 ] [ BC DE IY SP ];
#
#################################################################
## Macros
#################################################################
#
#macro setResultFlags(result) {
#	$(Z_flag) = (result == 0);
#	$(S_flag) = (result s< 0);
#}
#
#macro setAddCarryFlags(op1,op2) {
#	$(C_flag) = (carry(op1,zext($(C_flag))) || carry(op2,op1 + zext($(C_flag))));
#}
#
#macro setAddFlags(op1,op2) {
#	$(C_flag) = carry(op1,op2);
#}
#
#macro setSubtractCarryFlags(op1,op2) {
#	notC = ~$(C_flag);
#	$(C_flag) = ((op1 < sext(notC)) || (op2 < (op1 - sext(notC))));
#}
#
#macro setSubtractFlags(op1,op2) {
#	$(C_flag) = (op1 < op2);
#}
#
#macro push16(val16) {
#	SP = SP - 2;
#	*:2 SP = val16; 
#}
#
#macro pop16(ret16) {
#	ret16 = *:2 SP;
#	SP = SP + 2; 
#}
#
#macro push8(val8) {
#	SP = SP - 1;
#	ptr:2 = SP;
#	*:1 ptr = val8; 
#}
#
#macro pop8(ret8) {
#    ptr:2 = SP;
#	ret8 = *:1 ptr;
#	SP = SP + 1; 
#}
#
#################################################################
#
#ixMem8: (IX+simm8)  is IX & simm8								{ ptr:2 = IX + simm8; export *:1 ptr; }
#ixMem8: (IX-val)    is IX & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IX + simm8; export *:1 ptr; }
#
#iyMem8: (IY+simm8)  is IY & simm8								{ ptr:2 = IY + simm8; export *:1 ptr; }
#iyMem8: (IY-val)    is IY & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IY + simm8; export *:1 ptr; }
#
#Addr16: imm16		is imm16									{ export *:1 imm16; }
#
#Mem16: (imm16)		is imm16									{ export *:2 imm16; }
#
#RelAddr8: loc		is simm8  [ loc = inst_next + simm8; ]		{ export *:1 loc; }
#
#cc: "NZ"            is bits3_3=0x0                              { c:1 = ($(Z_flag) == 0); export c; }
#cc: "Z"             is bits3_3=0x1                              { c:1 = $(Z_flag); export c; }
#cc: "NC"            is bits3_3=0x2                              { c:1 = ($(C_flag) == 0); export c; }
#cc: "C"             is bits3_3=0x3                              { c:1 = $(C_flag); export c; }
#cc: "PO"            is bits3_3=0x4                              { c:1 = ($(PV_flag) == 0); export c; }
#cc: "PE"            is bits3_3=0x5                              { c:1 = $(PV_flag); export c; }
#cc: "P"             is bits3_3=0x6                              { c:1 = ($(S_flag) == 0); export c; }
#cc: "M"             is bits3_3=0x7                              { c:1 = $(S_flag); export c; }
#
#cc2: "NZ"            is bits3_3=0x4                              { c:1 = ($(Z_flag) == 0); export c; }
#cc2: "Z"             is bits3_3=0x5                              { c:1 = $(Z_flag); export c; }
#cc2: "NC"            is bits3_3=0x6                              { c:1 = ($(C_flag) == 0); export c; }
#cc2: "C"             is bits3_3=0x7                              { c:1 = $(C_flag); export c; }
#
#################################################################
#
#
#:LD IX,Mem16  is op0_8=0xdd & IX; op0_8=0x2a; Mem16 {
#	IX = Mem16;
#}
#
#:LD IY,Mem16  is op0_8=0xfd & IY; op0_8=0x2a; Mem16 {
#	IY = Mem16;
#}
#
#:LD Mem16,HL  is op0_8=0x22 & HL; Mem16 {
#	Mem16 = HL;
#}
#
#:LD Mem16,dRegPair4_2  is op0_8=0xed; op6_2=0x1 & dRegPair4_2 & bits0_4=0x3; Mem16 {
#	Mem16 = dRegPair4_2;
#}
#
#:LD Mem16,IX  is op0_8=0xdd & IX; op0_8=0x22; Mem16 {
#	Mem16 = IX;
#}
#
#:LD Mem16,IY  is op0_8=0xfd & IY; op0_8=0x22; Mem16 {
#	Mem16 = IY;
#}
#
#:NEG  is op0_8=0xed; op0_8=0x44 {
#	$(PV_flag) = (A == 0x80);
#	$(C_flag) = (A != 0);
#	A = -A;
#	setResultFlags(A);
#}
#
#:SET bits3_3,ixMem8  is op0_8=0xdd; op0_8=0xcb; ixMem8; op6_2=0x3 & bits3_3 & bits0_3=0x6 {
#	mask:1 = (1 << bits3_3);
#	val:1 = ixMem8;
#	ixMem8 = val | mask;
#}
#
#:SET bits3_3,iyMem8  is op0_8=0xfd; op0_8=0xcb; iyMem8; op6_2=0x3 & bits3_3 & bits0_3=0x6 {
#	mask:1 = (1 << bits3_3);
#	val:1 = iyMem8;
#	iyMem8 = val | mask;
#}
#
#:JP Addr16  is op0_8=0xc3; Addr16 {
#	goto Addr16;	
#}
#
#:JP cc,Addr16  is op6_2=0x3 & cc & bits0_3=0x2; Addr16 {
#	if (!cc) goto Addr16;
#}
#
#:JR RelAddr8  is op0_8=0x18; RelAddr8 {
#	goto RelAddr8;
#}
#
#:JR cc2,RelAddr8  is op6_2=0x0 & cc2 & bits0_3=0x0; RelAddr8 {
#	if (cc2) goto RelAddr8;
#}
#
#:JP (HL)  is op0_8=0xe9 & HL {
#	goto [HL];
#}
#
#:JP (IX)  is op0_8=0xdd & IX; op0_8=0xe9 {
#	goto [IX];
#}
#
#:JP (IY)  is op0_8=0xfd & IY; op0_8=0xe9 {
#	goto [IY];
#}
#
#:CALL Addr16  is op0_8=0xcd; Addr16 {
#    push16(&:2 inst_next);
#	call Addr16;
#}
#
#:CALL cc,Addr16  is op6_2=0x3 & cc & bits0_3=0x4; Addr16 {
#	if (!cc) goto inst_next;
#    push16(&:2 inst_next);
#	call Addr16;
#}
#
#:RET  is op0_8=0xc9 {
#	pop16(PC);
#	ptr:2 = zext(PC);
#	return [ptr];
#}
#
#:RET cc  is op6_2=0x3 & cc & bits0_3=0x0 {
#	if (!cc) goto inst_next;
#	pop16(PC);
#	ptr:2 = zext(PC);
#	return [ptr];
#}	
