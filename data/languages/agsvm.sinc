# sleigh specification file for AGSVM

define endian=little;

define alignment=4;

define space ram type=ram_space size=4 default;
define space register type=register_space size=4;
define space farStack type=ram_space size=4;
define space paramStack type=ram_space size=4;

# general purpose registers
define register offset=0x00 size=4 [ ax bx cx dx ];
# special meaning registers
define register offset=0x14 size=4 [ sp op mar ];
# utility registers not present in virtual machine
define register offset=0x20 size=4 [ pc counter _farsp ];

# operations used for p-code injection
define pcodeop movlitCallOther;
define pcodeop farcallCallOther;
define pcodeop setfuncargsCallOther;

# operations used as black-box functions
define pcodeop strcmp;

#TOKENS
define token operation (32)
    opcode   = ( 0,23)
    instance = (24,31)
;

define token operand (32)
    reg1 = (0, 2)
    reg2 = (0, 2)
    arg1 = (0,31) signed
    arg2 = (0,31) signed
    arg3 = (0,31) signed
;

attach variables [ reg1 reg2 ] [ _ sp mar ax bx cx op dx ];

# MARCO
macro push(x) {
    *:4 sp = x;
    sp = sp + 4;
}

macro pop(x) {
    sp = sp - 4;
    x = *:4 sp;
}

macro farpush(x) {
    *[farStack]:4 _farsp = x;
    _farsp = _farsp + 4;
}

macro farsubsp(x) {
    _farsp = _farsp - (x * 4);
}

# Constructors
dest: rel  is arg1 [ rel = inst_next + (arg1 * 4); ] {
    export *:4 rel;
}

# Instructions
# add (imm)
:add reg1, arg2        is opcode=0x01; reg1; arg2 {
    reg1 = reg1 + arg2;
}

# sub (imm)
:sub reg1, arg2        is opcode=0x02; reg1; arg2 {
    reg1 = reg1 - arg2;
}

# regtoreg
:mov reg2, reg1        is opcode=0x03; reg1; reg2 {
    reg2 = reg1;
}

# writelit
:memcpy arg2, arg1     is opcode=0x04; arg1; arg2 {
    if (arg1:4 == 1) goto <byte>;
    if (arg1:4 == 2) goto <word>;

    *:4 mar = arg2:4;
    goto inst_next;

    <byte>
    *:1 mar = arg2:1;
    goto inst_next;

    <word>
    *:2 mar = arg2:2;
}

# ret
:ret                   is opcode=0x05 {
    pop(pc);
    return [pc];
}

# littoreg
:mov reg1, arg2        is opcode=0x06; reg1; arg2 {
    reg1 = movlitCallOther(arg2:4);
}

# memread
:memread4 reg1         is opcode=0x07; reg1 {
    reg1 = *:4 mar;
}

# memwrite
:memwrite4 reg1        is opcode=0x08; reg1 {
    *:4 mar = reg1;
}

# mulreg
:mul reg1, reg2        is opcode=0x09; reg1; reg2 {
    reg1 = reg1 * reg2;
}

# divreg
:div reg1, reg2        is opcode=0x0a; reg1; reg2 {
    reg1 = reg1 / reg2;
}

# addreg
:add reg1, reg2        is opcode=0x0b; reg1; reg2 {
    reg1 = reg1 + reg2;
}

# subreg
:sub reg1, reg2        is opcode=0x0c; reg1; reg2 {
    reg1 = reg1 - reg2;
}

# bitand
:and reg1, reg2        is opcode=0xd; reg1; reg2 {
    reg1 = reg1 & reg2;
}

# bitor
:or reg1, reg2         is opcode=0xe; reg1; reg2 {
    reg1 = reg1 | reg2;
}

# isequal
:cmpeq reg1, reg2      is opcode=0x0f; reg1; reg2 {
    reg1 = zext(reg1 == reg2);
}

# notequal
:cmpneq reg1, reg2     is opcode=0x10; reg1; reg2 {
    reg1 = zext(reg1 != reg2);
}

# greater
:cmpgt reg1, reg2      is opcode=0x11; reg1; reg2 {
    reg1 = zext(reg1 s> reg2);
}

# lessthan
:cmplt reg1, reg2      is opcode=0x12; reg1; reg2 {
    reg1 = zext(reg1 s< reg2);
}

# gte
:cmpge reg1, reg2      is opcode=0x13; reg1; reg2 {
    reg1 = zext(reg1 s>= reg2);
}

# lte
:cmple reg1, reg2      is opcode=0x14; reg1; reg2 {
    reg1 = zext(reg1 s<= reg2);
}

# and (logical)
:land reg1, reg2       is opcode=0x15; reg1; reg2 {
    if (reg1 == 0) goto <false>;
    if (reg2 == 0) goto <false>;

    reg1 = 1;
    goto inst_next;

    <false>
    reg1 = 0;
}

# or (logical)
:lor reg1, reg2        is opcode=0x16; reg1; reg2 {
    if (reg1 != 0) goto <true>;
    if (reg2 != 0) goto <true>;

    reg1 = 0;
    goto inst_next;

    <true>
    reg1 = 1;
}

# call
:call reg1             is opcode=0x17; reg1 {
    push(&:4 inst_next);
    call [reg1];
}

# memreadb
:memread1 reg1         is opcode=0x18; reg1 {
    reg1 = *:1 mar;
}

# memreadw
:memread2 reg1         is opcode=0x19; reg1 {
    reg1 = *:2 mar;
}

# memwriteb
:memwrite1 reg1        is opcode=0x1a; reg1 {
    *:1 mar = reg1;
}

# memwritew
:memwrite2 reg1        is opcode=0x1b; reg1 {
    *:2 mar = reg1;
}

# jz
:jz dest               is opcode=0x1c; dest {
    if (ax == 0) goto dest;
}

# pushreg
:push reg1             is opcode=0x1d; reg1 {
    push(reg1);
}

# popreg
:pop reg1              is opcode=0x1e; reg1 {
    pop(reg1);
}

# jmp
:jmp dest              is opcode=0x1f; dest {
    goto dest;
}

# mul (imm)
:mul reg1, arg2        is opcode=0x20; reg1; arg2 {
    reg1 = reg1 * arg2;
}

# callext
:farcall reg1          is opcode=0x21; reg1 {
    farcallCallOther(reg1);
}

# pushreal
:farpush reg1          is opcode=0x22; reg1 {
    farpush(reg1);
}

# subrealstack
:farsubsp arg1         is opcode=0x23; arg1 {
    farsubsp(arg1);
}

# linenum
:sourceline arg1       is opcode=0x24; arg1 {
    # NOP
}

# callas
:callscr arg1          is opcode=0x25; arg1 {
#    TODO(adm244): research this
}

# thisbase
:thisaddr              is opcode=0x26; arg1 {
#    TODO(adm244): research this
}

# numfuncargs
:setfuncargs arg1      is opcode=0x27; arg1 {
    setfuncargsCallOther(arg1:4);
}

# modreg
:mod reg1, reg2        is opcode=0x28; reg1; reg2 {
    reg1 = reg1 % reg2;
}

# xorreg
:xor reg1, reg2        is opcode=0x29; reg1; reg2 {
    reg1 = reg1 ^ reg2;
}

# notreg
:lnot reg1             is opcode=0x2a; reg1 {
    if (reg1 == 0) goto <false>;

    reg1 = 0;
    goto inst_next;

    <false>
    reg1 = 1;
}

# shiftleft
:shl reg1, reg2        is opcode=0x2b; reg1; reg2 {
    reg1 = reg1 << reg2;
}

# shiftright
:shr reg1, reg2        is opcode=0x2c; reg1; reg2 {
    reg1 = reg1 >> reg2;
}

# callobj
:initobj reg1          is opcode=0x2d; reg1 {
#    TODO(adm244): implement it so we can figure out that next farcall is farcallas
    op = reg1;
}

# checkbounds
:assertlte reg1, arg2  is opcode=0x2e; reg1; arg2 {
#    assert(reg1:4, 0:4, arg2:4);
    # NOP
}

# memwriteptr
:memwrite.ptr reg1     is opcode=0x2f; reg1 {
#    FIXME(adm244): incorrect behavior
    *:4 mar = reg1;
}

# memreadptr
:memread.ptr reg1      is opcode=0x30; reg1 {
#    FIXME(adm244): incorrect behavior
    reg1 = *:4 mar;
}

# memzeroptr
:memzero.ptr           is opcode=0x31 {
#    FIXME(adm244): incorrect behavior
    *:4 mar = 0;
}

# meminit
:meminit reg1          is opcode=0x32; reg1 {
    *:4 mar = reg1;
}

# loadspoffs
:stackptr arg1         is opcode=0x33; arg1 {
    mar = sp - arg1;
}

# checknull
:assert mar            is opcode=0x34 & mar {
#    NOP
}

# fadd
:fadd reg1, arg2       is opcode=0x35; reg1; arg2 {
    reg1 = reg1 f+ arg2;
}

# fsub
:fsub reg1, arg2       is opcode=0x36; reg1; arg2 {
    reg1 = reg1 f- arg2;
}

# fmulreg
:fmul reg1, reg2       is opcode=0x37; reg1; reg2 {
    reg1 = reg1 f* reg2;
}

# fdivreg
:fdiv reg1, reg2       is opcode=0x38; reg1; reg2 {
    reg1 = reg1 f/ reg2;
}

# faddreg
:fadd reg1, reg2       is opcode=0x39; reg1; reg2 {
    reg1 = reg1 f+ reg2;
}

# fsubreg
:fsub reg1, reg2       is opcode=0x3a; reg1; reg2 {
    reg1 = reg1 f- reg2;
}

# fgreater
:fcmpgt reg1, reg2     is opcode=0x3b; reg1; reg2 {
    reg1 = zext(reg1 f> reg2);
}

# flessthan
:fcmplt reg1, reg2     is opcode=0x3c; reg1; reg2 {
    reg1 = zext(reg1 f< reg2);
}

# fgte
:fcmpge reg1, reg2     is opcode=0x3d; reg1; reg2 {
    reg1 = zext(reg1 f>= reg2);
}

# flte
:fcmple reg1, reg2     is opcode=0x3e; reg1; reg2 {
    reg1 = zext(reg1 f<= reg2);
}

# zeromemory
:memzero arg1          is opcode=0x3f; arg1 {
    counter = 0;

    <start>
    if (counter == arg1) goto inst_next;

    *:4 mar + counter = 0;
    counter = counter + 1;

    goto <start>;
}

# createstring
:strnew reg1           is opcode=0x40; reg1 {
#    TODO(adm244): reg1 is offset into .strings
#    reg1 = newobject(reg1);
#    reg1 = *[strings]:4 reg1;
    reg1 = reg1;
}

# stringsequal
:streq reg1, reg2      is opcode=0x41; reg1; reg2 {
    local tmp:4 = strcmp(reg1, reg2);

    if (tmp == 0) goto <true>;

    reg1 = 0;
    goto inst_next;

    <true>
    reg1 = 1;
}

# stringsnoteq
:strneq reg1, reg2     is opcode=0x42; reg1; reg2 {
    local tmp:4 = strcmp(reg1, reg2);

    if (tmp != 0) goto <true>;

    reg1 = 0;
    goto inst_next;

    <true>
    reg1 = 1;
}

# checknullreg
:assert reg1           is opcode=0x43; reg1 {
#    NOP
}

# loopcheckoff
:loopcheckoff          is opcode=0x44 {
#    NOP
}

# memzeroptrnd
:memzerond             is opcode=0x45 {
    *:4 mar = 0;
}

# jnz
:jnz dest              is opcode=0x46; dest {
    if (ax != 0) goto dest;
}

# dynamicbounds
:dynamicbounds reg1    is opcode=0x47; reg1 {
#    NOP
}

# newarray
:arrnew reg1, arg2, arg3  is opcode=0x48; reg1; arg2; arg3 {
    reg1 = newobject(reg1, arg2:4, arg3:4);
}

# newuserobject
:objnew reg1, arg2     is opcode=0x49; reg1; arg2 {
    reg1 = newobject(reg1, arg2:4);
}
